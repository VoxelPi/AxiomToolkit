package net.voxelpi.axiom.cli

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.NoOpCliktCommand
import com.github.ajalt.clikt.core.main
import com.github.ajalt.clikt.core.subcommands
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.arguments.optional
import com.github.ajalt.clikt.parameters.options.default
import com.github.ajalt.clikt.parameters.options.flag
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.types.choice
import com.github.ajalt.clikt.parameters.types.int
import com.github.ajalt.clikt.parameters.types.path
import com.github.ajalt.mordant.terminal.Terminal
import com.github.ajalt.mordant.widgets.Text
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withTimeout
import net.voxelpi.axiom.arch.Architecture
import net.voxelpi.axiom.arch.ax08.AX08Architecture
import net.voxelpi.axiom.arch.dev08.DEV08Architecture
import net.voxelpi.axiom.arch.dev16.DEV16Architecture
import net.voxelpi.axiom.arch.dev32.DEV32Architecture
import net.voxelpi.axiom.arch.dev64.DEV64Architecture
import net.voxelpi.axiom.arch.mcpc08.MCPC08Architecture
import net.voxelpi.axiom.arch.mcpc16.MCPC16Architecture
import net.voxelpi.axiom.bridge.AxiomBridge
import net.voxelpi.axiom.cli.emulator.Emulator
import kotlin.io.path.absolutePathString
import kotlin.io.path.readBytes

class AxiomCommand : CliktCommand(name = "axiom") {

    override fun run() = Unit
}

class AssemblerCommand(
    val architectures: Map<String, Architecture>,
) : CliktCommand(name = "asm") {

    val input by argument(help = "The input file")
        .path(mustExist = true, canBeFile = true, canBeDir = false, mustBeReadable = true)
    val output by argument(help = "The output file")
        .path()
        .optional()
    val position by option("--position", help = "The position of the program in memory")
        .int()
        .default(0)
    val generateRaw by option("-r", "--raw", help = "If a raw axm file should be generated")
        .flag()
    val inverseInstructionByteOrder by option("--inverse", help = "If the instruction byte order should be inverted")
        .flag()
    val architecture by option("-a", "--arch", help = "Target architecture to assembled for")
        .choice(architectures)
        .default(AX08Architecture(AX08Architecture.Variant.LITE))

    override fun run() {
//         val inputFilePath = input.absolute().normalize()
//         if (!inputFilePath.exists() || !inputFilePath.isRegularFile()) {
//             println("The input file $inputFilePath does not exist.")
//             exitProcess(1)
//         }
//
//         val outputFilePath = (output ?: inputFilePath.parent.resolve(inputFilePath.nameWithoutExtension + ".bin")).normalize()
//         println("Assembling \"${inputFilePath.absolutePathString()}\" to \"${outputFilePath.absolutePathString()}\"")
//
//         val rawFile = outputFilePath.parent / "${outputFilePath.nameWithoutExtension}.raw.${Assembler.AXIOM_ASM_EXTENSION}"
//
//         val assembler = Assembler(listOf(Path(".").absolute().normalize()))
//
//         val program = assembler.assemble(inputFilePath, architecture, offset = position).getOrElse { exception ->
//             echo(Text(TextColors.brightRed(TextStyles.bold("COMPILATION FAILED"))), err = true)
//             echo(Text(generateCompilationStackTraceMessage(exception)), err = true)
//             exitProcess(1)
//         }
//
//         if (generateRaw) {
//             rawFile.writeText(
//                 program.data.joinToString("\n") { instruction ->
//                     var text = instruction.toString().padEnd(32)
//                     val source = instruction.meta[Assembler.SOURCE_INSTRUCTION_META_KEY] as? SourceLink
//                     if (source != null) {
//                         when (source) {
//                             is SourceLink.CompilationUnitSlice -> {
//                                 text += " # ${"\"${source.text.trim()}\"".padEnd(32)} at ${source.line.toString().padStart(5)}:${source.column.toString().padEnd(2)} of unit \"${source.unit.id}\""
//                             }
//
//                             is SourceLink.Generated -> {
//                                 text += " # ${"\"${source.text.trim()}\"".padEnd(32)} generated by \"${source.generator}\""
//                             }
//                         }
//                     }
//                     text
//                 },
//             )
//         }
//
//         if (architecture.hasEncodedFormat) {
//             val encodedProgram = architecture.encodeProgram(program, invertByteOrder = inverseInstructionByteOrder).getOrElse { exception ->
//                 // TODO: Maybe generate a sourced exception?
//                 echo(Text(generateCompilationStackTraceMessage(exception)), err = true)
//                 exitProcess(1)
//             }
//             outputFilePath.writeBytes(encodedProgram.toByteArray())
//             println("Assembled ${program.data.size} instructions (${encodedProgram.size} bytes)")
//         } else {
//             println("Assembled ${program.data.size} instructions")
//         }
    }
}

object BridgeCommand : NoOpCliktCommand(name = "bridge") {

    override fun aliases(): Map<String, List<String>> = mapOf(
        "flash" to listOf("upload")
    )
}

class BridgeUploadCommand(
    val architectures: Map<String, Architecture>,
) : CliktCommand(name = "upload") {

    val programFile by argument(help = "The file to upload").path(mustExist = true, mustBeReadable = true)

    val architecture by option("-a", "--arch", help = "Target architecture")
        .choice(architectures)
        .default(AX08Architecture(AX08Architecture.Variant.LITE))
    val port by option("-p", "--port", help = "The serial port on which the computer is connected")
    val baudRate by option("-b", "--baud", help = "The serial baud rate that should be used")
        .int()

    override fun run() {
        val bridge = AxiomBridge.connect(port!!, 115200, architecture).getOrElse { exception ->
            echo("${TextColors.brightRed(TextStyles.bold("ERROR"))} ${TextColors.brightRed("Unable to open port $port. Please make sure the bridge is connected at the specified port.")}", err = true)
            return
        }

        val bridgeInfo = runBlocking {
            withTimeout(10000) {
                bridge.fetchInfo().getOrElse { exception ->
                    echo("${TextColors.brightRed(TextStyles.bold("ERROR"))} ${TextColors.brightRed("Unable to connect to bridge at port $port. Please make sure the bridge is connected at the specified port. ${exception.message}")}", err = true)
                    exitProcess(1)
                }
            }
        }
        echo("Connected to ${architecture.id} bridge v${bridgeInfo.version} (commit: ${bridgeInfo.gitVersion}, protocol: ${bridgeInfo.protocolVersion})")

        echo("Uploading \"${programFile.normalize().absolutePathString()}\"")
        val uploadTime = measureTime {
            runBlocking {
                withTimeout(10000) {
                    bridge.uploadProgram(programFile.readBytes()).getOrElse { exception ->
                        echo("${TextColors.brightRed(TextStyles.bold("ERROR"))} Failed to upload the program. ${exception.message}")
                        exitProcess(1)
                    }
                }
            }
        }
        echo("${TextColors.brightGreen("Verify complete")} (${String.format("%.3f", uploadTime.inWholeMilliseconds / 1000.0)}s)")
        exitProcess(0)
    }
}

class EmulatorCommand(
    val architectures: Map<String, Architecture>,
) : CliktCommand(name = "emulator") {

    val program by argument(help = "The program")
        .path(mustExist = true, canBeFile = true, canBeDir = false, mustBeReadable = true)
        .optional()
    val architecture by option("-a", "--arch", help = "Target architecture to be emulated")
        .choice(architectures)
        .default(AX08Architecture(AX08Architecture.Variant.LITE))

    override fun run() {
        Emulator(architecture, program)
    }
}

fun main(args: Array<String>) {
    val terminal = Terminal()

    val architectures: Map<String, Architecture> = listOf(
        AX08Architecture(AX08Architecture.Variant.NORMAL),
        AX08Architecture(AX08Architecture.Variant.LITE),
        DEV08Architecture,
        DEV16Architecture,
        DEV32Architecture,
        DEV64Architecture,
        MCPC08Architecture,
        MCPC16Architecture,
    ).associateBy(Architecture::id)

    AxiomCommand()
        .subcommands(
            AssemblerCommand(architectures),
            BridgeCommand.apply {
                subcommands(BridgeUploadCommand(architectures))
            },
            EmulatorCommand(architectures),
        )
        .main(args)
}
