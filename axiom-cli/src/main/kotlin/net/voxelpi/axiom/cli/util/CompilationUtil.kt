package net.voxelpi.axiom.cli.util

import com.github.ajalt.mordant.rendering.TextColors

// TODO: Assembler v2

private val sourceTextStyle = TextColors.brightCyan
private val sourceRefStyle = TextColors.brightYellow
private val sourceUnitStyle = TextColors.brightGreen
private val errorStyle = TextColors.brightRed
//
// fun generateCompilationStackTraceMessage(exception: Throwable): String {
//     val lines = mutableListOf<String>()
//     buildCompilationStackTrace(exception, lines)
//     return lines.joinToString("\n") { it }
// }

// private fun errorSourceText(source: SourceLink.CompilationUnitSlice): String {
//     var iStatementStart = source.index
//     while (iStatementStart > 0) {
//         --iStatementStart
//         if (source.unit.content[iStatementStart] in listOf('\n', '\r', ';')) {
//             ++iStatementStart
//             break
//         }
//     }
//     while (iStatementStart < source.index + source.length) {
//         if (!source.unit.content[iStatementStart].isWhitespace()) {
//             break
//         }
//         ++iStatementStart
//     }
//
//     var iStatementEnd = source.index + source.length
//     while (iStatementEnd < source.unit.content.length) {
//         if (source.unit.content[iStatementEnd] in listOf('\n', '\r', ';')) {
//             break
//         }
//         ++iStatementEnd
//     }
//     while (iStatementEnd > iStatementStart) {
//         if (!source.unit.content[iStatementEnd - 1].isWhitespace()) {
//             break
//         }
//         --iStatementEnd
//     }
//
//     val statementText = source.unit.content.substring(iStatementStart, iStatementEnd)
//     val highlightStart = (source.index - iStatementStart).coerceAtLeast(0)
//     val highlightEnd = highlightStart + (source.length).coerceAtMost(iStatementEnd - iStatementStart)
//     return "\"${statementText.substring(0, highlightStart)}${TextStyles.underline(statementText.substring(highlightStart, highlightEnd))}${statementText.substring(highlightEnd)}\""
// }
//
// private fun buildCompilationStackTrace(exception: Throwable, messages: MutableList<String>) {
//     val prefix = TextColors.gray("${"    ".repeat(messages.size)}  â”” ")
//     when (exception) {
//         is ParseException -> {
//             val source = exception.source
//             when (source) {
//                 is SourceLink.CompilationUnitSlice -> {
//                     messages += "$prefix Failed to parse ${sourceTextStyle(errorSourceText(source))} at ${sourceRefStyle("${source.line + 1}")}:${sourceRefStyle("${source.column + 1}")} of unit ${sourceUnitStyle("\"${source.unit.id}\"")}: ${errorStyle(exception.message ?: "")}"
//                 }
//                 is SourceLink.Generated -> {
//                     messages += "$prefix Failed to parse ${sourceTextStyle("\"${source.text}\"")} ${sourceRefStyle("generated by \"${source.generator}\"")}: ${errorStyle(exception.message ?: "")}"
//                 }
//             }
//         }
//         is SourceCompilationException -> {
//             val source = exception.source
//             when (source) {
//                 is SourceLink.CompilationUnitSlice -> {
//                     messages += "$prefix Failed to compile ${sourceTextStyle(errorSourceText(source))} at ${sourceRefStyle("${source.line + 1}")}:${sourceRefStyle("${source.column + 1}")} of unit ${sourceUnitStyle("\"${source.unit.id}\"")}: ${errorStyle(exception.message ?: "")}"
//                 }
//                 is SourceLink.Generated -> {
//                     messages += "$prefix Failed to compile ${sourceTextStyle("\"${source.text}\"")} ${sourceRefStyle("generated by \"${source.generator}\"")}: ${errorStyle(exception.message ?: "")}"
//                 }
//             }
//         }
//         is CompilationException -> {
//             messages += "$prefix Failed to compile code: ${errorStyle(exception.message ?: "")}"
//         }
//         else -> {
//             messages += "$prefix Unexpected exception: ${errorStyle(exception.message ?: "")}"
//         }
//     }
//     exception.cause?.let { buildCompilationStackTrace(it, messages) }
// }
